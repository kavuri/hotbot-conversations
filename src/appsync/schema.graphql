# For list of comments
type CommentConnection {
	items: [CommentOutputType]
	nextToken: String
}

# Comment input
input CommentInput {
	o_id: ID!
	comment_id: ID!
	content: String!
	created_at: AWSDateTime!
	commented_by: String!
}

# Comment object type
type CommentOutputType {
	o_id: ID!
	comment_id: ID!
	content: String!
	created_at: AWSDateTime!
	commented_by: String!
}

input CreateGuestOrderInput {
	hotel_id: ID!
	user_id: ID!
	o_id: ID!
	room_no: String!
	o_items: [OrderItemInput!]!
	o_time: AWSDateTime!
	o_status: StatusInput!
	o_priority: PriorityInput!
}

type GuestOrderConnection {
	orders: [GuestOrderOutputType]
	nextToken: String
}

type GuestOrderOutputType {
	hotel_id: ID!
	user_id: ID!
	o_id: ID!
	room_no: String!
	o_items: [OrderItemType!]!
	o_time: AWSDateTime!
	o_status: StatusType!
	o_priority: PriorityType!
}

type Mutation {
	createOrder(
		hotel_id: ID!,
		user_id: ID!,
		o_id: ID!,
		room_no: String!,
		o_items: [OrderItemInput!]!,
		o_time: AWSDateTime!,
		o_status: StatusInput!,
		o_priority: PriorityInput!
	): GuestOrderOutputType!
}

input OrderItemInput {
	item_name: String!
	category: String!
	req_count: Int
	res_count: Int
}

type OrderItemType {
	item_name: String!
	category: String!
	req_count: Int
	res_count: Int
}

enum Priority {
	urgent
	asap
	leisure
}

type PriorityConnection {
	items: [PriorityType]
	nextToken: String
}

# Similar to comments, need to keep track of the various priority changes
input PriorityInput {
	_id: ID!
	priority: Priority!
	created_at: AWSDateTime!
	updated_by: String!
}

type PriorityType {
	_id: ID!
	priority: Priority!
	created_at: AWSDateTime!
	updated_by: String!
}

type Query {
	getGuestOrder(hotel_id: ID!, room_no: String!): GuestOrderOutputType
	listGuestOrders(filter: TableGuestOrderFilterInput, limit: Int, nextToken: String): GuestOrderConnection
}

enum Status {
	new
	progress
	done
	cant_serve
	cancelled
}

type StatusConnection {
	items: [StatusType]
	nextToken: String
}

# Similar to comments, need to keep track of the various status changes
input StatusInput {
	_id: ID!
	status: Status!
	created_at: AWSDateTime!
	updated_by: String!
}

type StatusType {
	_id: ID!
	status: Status!
	created_at: AWSDateTime!
	updated_by: String!
}

type Subscription {
	onCreateGuestOrder(hotel_id: ID!): GuestOrderOutputType
		@aws_subscribe(mutations: ["createOrder"])
}

input TableBooleanFilterInput {
	ne: Boolean
	eq: Boolean
}

input TableFloatFilterInput {
	ne: Float
	eq: Float
	le: Float
	lt: Float
	ge: Float
	gt: Float
	contains: Float
	notContains: Float
	between: [Float]
}

input TableGuestOrderFilterInput {
	hotel_id: TableIDFilterInput
	o_id: TableIDFilterInput
	room_no: TableStringFilterInput
	o_items: TableStringFilterInput
	o_time: TableStringFilterInput
	o_status: TableStringFilterInput
	o_priority: TableStringFilterInput
	o_completion_time: TableStringFilterInput
	o_cancelled_by: TableStringFilterInput
	o_last_update_at: TableStringFilterInput
	o_comments: TableStringFilterInput
}

input TableIDFilterInput {
	ne: ID
	eq: ID
	le: ID
	lt: ID
	ge: ID
	gt: ID
	contains: ID
	notContains: ID
	between: [ID]
	beginsWith: ID
}

input TableIntFilterInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	contains: Int
	notContains: Int
	between: [Int]
}

input TableStringFilterInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	contains: String
	notContains: String
	between: [String]
	beginsWith: String
}

schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}